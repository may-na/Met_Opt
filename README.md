# Лабораторная работа №1  
## Решение задачи линейного программирования двухфазным симплекс-методом  
### Студент: **Майстренко Анастасия Николаевна**  
### Поток: **МетОпт 1.2**

---

# 1. Введение

Цель работы - получить навыки решения задач линейного программирования (ЗЛП) методом симплекс-метода, освоить приведение задачи к каноническому виду, построение вспомогательной задачи и реализацию двухфазного симплекс-метода на языке Python.  
Для проверки корректности решения выполнено сравнение с Microsoft Excel Solver.

---

# 2. Постановка задачи

Решить следующую задачу линейного программирования:

**Целевая функция и Ограничения:**

![Целевая функция](https://github.com/may-na/MetOpt-/blob/main/Снимок%20экрана%202025-12-09%20в%2011.44.06.png)

---

# Алгоритм решения задачи линейного программирования
## Двухфазный симплекс-метод (реализация в программе lab1.py)

![Блочная схема](https://github.com/may-na/Met_Opt/blob/main/Схема.png)

## 1. Чтение входных данных

1. Программа открывает текстовый файл и считывает:
   - тип задачи (max/min),
   - количество переменных и ограничений,
   - коэффициенты целевой функции,
   - систему ограничений и знаки (≤, ≥, =).

2. Данные парсятся в структуру, удобную для дальнейших преобразований.

## 2. Нормализация ограничений

Для каждого ограничения выполняется проверка знака правой части:
Если b < 0, все коэффициенты и знак разворачиваются.
После нормализации все ограничения имеют b ≥ 0.
Это необходимо для корректного построения симплекс-таблицы.

## 3. Приведение задачи к каноническому виду

Программа преобразует все ограничения так, чтобы получить равенства вида:
A x = b, x ≥ 0
Используются следующие правила:

1. Ограничение вида ≤
Добавляется slack-переменная:
a₁ x₁ + … + aₙ xₙ + s = b

2. Ограничение вида ≥
Добавляется surplus-переменная и искусственная переменная:
a₁ x₁ + … + aₙ xₙ – s + a = b

3. Ограничение вида =
Добавляется искусственная переменная:
a₁ x₁ + … + aₙ xₙ + a = b

Индекс каждой новой переменной учитывается в таблице.

---

## 4. Построение таблицы для Фазы I

Если в задаче появились искусственные переменные, необходимо сформировать вспомогательную задачу:

w = a₁ + a₂ + … + aₖ → min
(или в реализованном виде: w = −Σaᵢ → max)

Далее:

1. Строится симплекс-табло.
2. В строку целевой функции добавляются строки базиса, содержащие искусственные переменные (канонизация).
3. Запускается стандартный симплекс-метод до достижения оптимума.

---

## 5. Проверка допустимости решения

После завершения Фазы I:

- Если w* > 0, то исходная задача не имеет допустимых решений.
- Если w* = 0, задача совместна, можно переходить к Фазе II.

w* = оптимальное значение функции w после выполнения Фазы I.

---

## 6. Подготовка таблицы для Фазы II

1. Искусственные переменные удаляются.
2. Перестраивается индексный вектор базиса.
3. Формируется строка исходной целевой функции:

Z = c – Σ(c_bi * A_i)
где A_i — строки ограничений, а c_bi — коэффициенты целевой функции при базисных переменных.

---

## 7. Симплекс-метод (Фаза II)

Фаза II — классический симплекс-метод:

1. Выбирается входящая переменная - столбец с максимальным положительным коэффициентом в строке цели.
2. Выполняется проверка ограниченности задачи.
3. Выбирается выходящая переменная по правилу минимума отношения:
b_i / a_ij, где a_ij > 0.
4. Проводится pivot-операция (нормализация строки и зануление остальных строк по столбцу).
5. Процесс повторяется до тех пор, пока строка цели не станет невозрастающей.

---

## 8. Получение результата

После завершения Фазы II:

1. Оптимальное решение считывается из базиса:
x_i = b_j, если переменная x_i находится в базисе;
в противном случае x_i = 0.

2. Оптимальное значение целевой функции берётся из правого столбца строки цели.

---

## 9. Возможные отдельные случаи

Алгоритм корректно обрабатывает:

- отсутствие допустимого решения;
- неограниченность целевой функции;
- вырожденность (через малое ε);
- искусственные переменные в базисе.

---

# Итог

Алгоритм реализует полный двухфазный симплекс-метод:
- автоматически приводит задачу к каноническому виду;
- решает вспомогательную задачу;
- выполняет оптимизацию исходной задачи;
- корректно определяет тип решения.

# Инструкция как запустить программу
Скачать репозиторий, перейти в главную директорию, после чего вызвать в консоли python3 lab1.py lp_input.txt

# Демонстрация работы 
Вариант задания - №5

Вывод из консоли при результате выполнения работы на ЯП Питон и солвера в Excel:

![Python](https://github.com/may-na/Met_Opt/blob/main/Вывод%20VScode.png)
![Excel](https://github.com/may-na/Met_Opt/blob/main/Вывод%20Excel.png)

# Рефлективный вывод
Полезным оказалось поэтапное построение решения: от математической модели до рабочего кода. Особенно хорошо стало понятно, зачем нужны искусственные переменные и вспомогательная задача Фазы I.
